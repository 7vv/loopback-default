# LoopBack start

The project is generated by [LoopBack](http://loopback.io).

## step1
LoopBack cli install
-`npm install loopback-cli -g`

## step2
create LoopBack server
- `lb`

## step3
모델 종류
- Model                   `기본 빈 모델`
- PersistedModel          `데이터 베이스를 사용하는 API 모델 CRUD 제공`
- ACL                     `인증 모델`
- AccessToken             `인증 토큰 모델`
- Application
- Change
- Checkpoint

create LoopBack model
- `lb model`

## step4
서버 실행하기
- `node .` or `nodemon .`   <- 사용가능

## Model connect DataSource
모델을 DataSource에 연결하기.

- lb datasource `데이터 소스 설정`
- /server/model-config.json 에서 원하는 db key값에 datasource 연결
- datasource에 사용할 수 있는 함수 사용해보기 `ex) app.models.CoffeeShop.create, update 등등..`
- 예제 API
```
 app.models.abs.create([{
      name: 'Bel Cafe',
      city: 'Vancouver'
    }, {
      name: 'Three Bees Coffee House',
      city: 'San Mateo'
    }, {
      name: 'Caffe Artigiano',
      city: 'Vancouver'
    }], function(err, abss) {
      if (err) throw err;

      console.log('Models created: \n', abss);
    });
```

## Static 웹 페이지 추가하기
API 서버로만 사용할거라서 정적 웹 페이지가 필요없지만 언젠간 사용할거 같아서 작성

- /server/middleware.json 에다가 정의한다.
```
  "files": {
    "loopback#static": {
      "params": "$!../client"
    }
  },
```
- $! 문자는 해당 파일 경로 위치를 반환함
- /client/index.html 위치에 웹 페이지 파일 작성

추가로 부팅 스크립트를 이용해 사용자 정의 라우터를 만들 수 있다.
- /server/boot/routes.js 생성 routes.js는 임의로 정할 수 있다.
- 아래 코드 작성 Express 라우터랑 같아서 설명 생략

```
module.exports = function(app) {
  //Express 기반이라서 Express 형태로 사용하면 된다.
  app.get('/ping', function(req, res) {
    res.send('pong');
  });

  const api = app.loopback.Router();
  const user = app.loopback.Router();
  api.get('/', (req, res, next) => {
    res.send('this api')
  })

  api.get('/get', (req, res, next) => {
    res.send('this get api')
  })

  user.get('/', (req, res, next) => {
    res.send('this user')
  })

  user.get('/get', (req, res, next) => {
    res.send('this get user')
  })


  app.use('/user', user)
  app.use('/api', api);
}
```

## DataSource 마이그래이션 진행하기
여러가지 디비와 테이블, 스키마가 섞여 있는 경우도 마이그래이션 작업이 가능하다.

서로 다른 DB를 공통적으로 처리할 수 있다는 것을 느끼게 된다.

서버가 시작 될 때 작동해야 하기 때문에 `/server/boot`에 파일을 하나 생성해 준다.

async await를 사용해서 동기적으로 처리하는 예제 코드

`mar.js`
```
//DB 마이그레이션 작업
module.exports = async function (app) {
  const mongodb = app.dataSources.mongodb;
  const mysql = app.dataSources.mysql;

  //create reviews
  createReviews = async (reviewers, coffeeShops) => {
    return new Promise((resolve, reject) => {
      mongodb.automigrate('Review', (err) => {
        if (err) reject(err)
        const Review = app.models.Review;
        const DAY_IN_MILLISECONDS = 1000 * 60 * 60 * 24;
        Review.create([
          {
            date: Date.now() - (DAY_IN_MILLISECONDS * 4),
            rating: 5,
            comments: 'A very good coffee shop.',
            publisherId: reviewers[0].id,
            coffeeShopId: coffeeShops[0].id,
          }
        ], (err, doc) => {
          if (err) console.log('Create Review Error', err);
          resolve(doc);
        });
      });
    })
  }

  createCoffeShop = async () => {
    return new Promise((resolve, reject) => {
      mysql.automigrate('abs', err => {
        if (err) reject(err)

        const Abs = app.models.Abs;
        Abs.create([
          {
            name: 'Bel Cafe',
          },
          {
            name: 'Three Bees Coffee House',
          },
          {
            name: 'Caffe Artigiano',
          }
        ], (err, doc) => {
          if (err) console.log('Boot Mongodb marg Error', err)
          resolve(doc);
        });
      })
    })
  }

  createReviewer = async () => {
    return new Promise((resolve, reject) => {
      mongodb.automigrate('Reviewer', err => {
        if (err) reject(err)

        const Reviewer = app.models.Reviewer;

        Reviewer.create([
          {
            email: 'sungho@naver.com',
            password: '1270'
          }
        ], (err, doc) => {
          if (err) console.log('Boot Mysql marg Error', err)
          resolve(doc);
        });
      })
    })
  }




  const coffeDoc = await createCoffeShop();
  const reviewerDoc = await createReviewer();
  console.log('1', coffeDoc);
  console.log('2', reviewerDoc)
  console.log('created Two marg')
  const review = await createReviews(reviewerDoc, coffeDoc);
  console.log('3', review)
}

```

## 모델 간 관계 정의하기
모델 간 관계를 정의할 수 있다. 여러가지 관계 설정도 가능하다.

신기하게 한국어로 나온다.

`모델 abs에는 많은 Review 모델이 있다`
- lb relation
- ? 관계(from)를 작성할 모델 선택: abs
- ? 관계 유형: has many
- ? 관계(to)를 작성할 모델 선택: Review
- ? 관계의 특성 이름 입력: reviews
- ? 사용자 외부 키 입력(선택적):
- ? through 모델이 필수입니까? No
- ? REST API에서 관계가 중첩되도록 허용: No
- ? 관계가 포함되지 않도록 설정: No

`모델 abs에는 많은 Reviwer모델이 있다.`
- lb relation
- ? 관계(from)를 작성할 모델 선택: abs
- ? 관계 유형: has many
- ? 관계(to)를 작성할 모델 선택: Reviewer
- ? 관계의 특성 이름 입력: reviewers              `공백으로 입력하면 자동으로 작성된다.`
- ? 사용자 외부 키 입력(선택적):
- ? through 모델이 필수입니까? No
- ? REST API에서 관계가 중첩되도록 허용: No
- ? 관계가 포함되지 않도록 설정: No

`Review는 abs에 속한 모델이다. `
- lb relation
- ? 관계(from)를 작성할 모델 선택: Review
- ? 관계 유형: belongs to                  `어딘가에 속할 모델이다.`
- ? 관계(to)를 작성할 모델 선택: abs           `Review모델은 abs모델에 속한다`
- ? 관계의 특성 이름 입력: abs
- ? 사용자 외부 키 입력(선택적):
- ? REST API에서 관계가 중첩되도록 허용: No
- ? 관계가 포함되지 않도록 설정: No

`Review는 Reivwer에 속하고 외래 키 이다. publisherId`
- lb relation
- ? 관계(from)를 작성할 모델 선택: Review
- ? 관계 유형: belongs to
- ? 관계(to)를 작성할 모델 선택: Reviewer
- ? 관계의 특성 이름 입력: reviewer
- ? 사용자 외부 키 입력(선택적): publisherId
- ? REST API에서 관계가 중첩되도록 허용: No
- ? 관계가 포함되지 않도록 설정: No

`Reivwer에는 많은 Review가 있다. 외래 키 이다. publisherId`

- lb relation
- ? 관계(from)를 작성할 모델 선택: Reviewer
- ? 관계 유형: has many
- ? 관계(to)를 작성할 모델 선택: Review
- ? 관계의 특성 이름 입력: reviews
- ? 사용자 외부 키 입력(선택적): publisherId
- ? through 모델이 필수입니까? No
- ? REST API에서 관계가 중첩되도록 허용: No
- ? 관계가 포함되지 않도록 설정: No

## 엑세스 제어 정의하기
LoopBack는 모델을 통해 데이터를 엑세스 하는데 액세스를 모델별로 제한을 걸 수 있다.
ACL을 사용하면 된다.

테스트 엑세스 규칙 `Review` 모델에 적용된다.
- 누구나 리뷰를 읽을 수 있지만 리뷰를 작성, 수정 또는 삭제하려면 로그인해야합니다.
- 누구나 사용자로 등록 할 수 있습니다. 로그인하고 로그 아웃하십시오.
- 로그인 한 사용자는 새로운 리뷰를 작성하고 자신의 리뷰를 편집하거나 삭제할 수 있습니다. 그러나 그들은 커피 샵을 수정할 수 없습니다.


모든 종단점을 모두 거부합니다 . ACL을 정의 할 때 종종 시작점이됩니다. 특정 동작에 대해 선택적으로 액세스를 허용 할 수 있기 때문입니다.

- lb acl
- ? Select the model to apply the ACL entry to: (all existing models)   `모든 모델 적용`
- ? Select the ACL scope: All methods and properties                    `모든 메소즈 및 특성에 적용`
- ? Select the access type: All (match all types)                       `모든 유형과 일치`
- ? Select the role: All users                                          `모든 유저에 적용 (모든 사용자)`
- ? Select the permission to apply: Explicitly deny access              `명시적으로 엑세스 거부 `

일단 모든 접근 거부하고 사용할 모델들을 허용한다.

누구나 리뷰를 읽게 하기 Review 모델을 선택해서 작업한다.

- lb acl
- ACL 항목을 적용할 모델 선택: Review
- ACL 범위 선택: 모든 메소드 및 특성
- 액세스 유형 선택: 읽기
- 역할 선택 모든 사용자
- 적용할 권한 선택 명시적으로 액세스 부여

인증 된 사용자가 abs 를 읽을 수 있도록 허용하기 -> 로그인 한 경우 모든 abs 모델 볼 수 있다.

- lb acl
- ACL 항목을 적용할 모델 선택: abs
- ACL 범위 선택: 모든 메소드 및 특성
- 액세스 유형 선택: 읽기
- 역할 선택 인증된 모든 사용자
- 적용할 권한 선택 명시적으로 액세스 부여

인증 된 사용자가 리뷰를 작성할 수 있게 특정 메소드만 부여한다 `create` 메소드에 권한 하용

- lb acl
- ACL 항목을 적용할 모델 선택: Review
- ACL 범위 선택: 단일 메소드
- 메소드 이름 입력 create
- 역할 선택 인증된 모든 사용자
- 적용할 권한 선택 명시적으로 액세스 부여

리뷰 작성자가 변경 작업을 수행 할 수 있게 한다.

- lb acl
- ACL 항목을 적용할 모델 선택: Review
- ACL 범위 선택: 모든 메소드 및 특성
- 액세스 유형 선택: 쓰기
- 역할 선택 오브젝트를 소유하는 사용자
- 적용할 권한 선택 명시적으로 액세스 부여

